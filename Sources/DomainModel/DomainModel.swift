struct DomainModel {
    var text = "Hello, World!"
        // Leave this here; this value is also tested in the tests,
        // and serves to make sure that everything is working correctly
        // in the testing harness and framework.
}

////////////////////////////////////
// Money
//

extension Int {
// a la "DoubleExtensions" class generated by the compil
  var GBP: Int {
    let x : Int = Int((Double(self) * 2).rounded())
    return x
  }
  var USD: Int {
    let x : Int = Int((Double(self)).rounded())
    return x
  }
    var EUR: Int {
        let x : Int = Int((Double(self) * 2 / 3).rounded())
        return x
    }
    var CAN: Int {
        let x : Int = Int((Double(self) * 0.8).rounded())
        return x
    }
}

extension Int {
// a la "DoubleExtensions" class generated by the compil
  var realGBP: Int {
    let x : Int = Int((Double(self) / 2).rounded())
    return x
  }
    var realUSD: Int {
    let x : Int = Int((Double(self)).rounded())
    return x
  }
    var realEUR: Int {
        let x : Int = Int((Double(self) * 1.5).rounded())
        return x
    }
    var realCAN: Int {
        let x : Int = Int((Double(self) * 1.25).rounded())
        return x
    }
}

public struct Money {
    
    var amount : Int
    var currency : String
    var value : Int
    
    init(amount am: Int, currency cu: String) {
        amount = am
        currency = cu
        switch currency {
        case "USD":
            value = amount.USD
        case "GBP":
            value = amount.GBP
        case "EUR":
            value = amount.EUR
        case "CAN":
            value = amount.CAN
        default:
            print("Does Not Support This Currency")
            value = 0
        }
    }
    
    func convert(_ target: String) -> Money {
        switch target {
        case "USD":
            let newValue = value.realUSD
            let newCurrency = target
            return Money(amount: newValue, currency: newCurrency)
        case "GBP":
            let newValue = value.realGBP
            let newCurrency = target
            return Money(amount: newValue, currency: newCurrency)
        case "EUR":
            let newValue = value.realEUR
            let newCurrency = target
            return Money(amount: newValue, currency: newCurrency)
        case "CAN":
            let newValue = value.realCAN
            let newCurrency = target
            return Money(amount: newValue, currency: newCurrency)
        default:
            print("Does Not Support This Currency")
            return self
        }
    }
    
    func add(_ mo: Money) -> Money {
        switch mo.currency {
        case "USD":
            let newValue = value.realUSD + mo.amount
            return Money(amount: newValue, currency: mo.currency)
        case "GBP":
            let newValue = value.realGBP + mo.amount
            return Money(amount: newValue, currency: mo.currency)
        case "EUR":
            let newValue = value.realEUR + mo.amount
            return Money(amount: newValue, currency: mo.currency)
        case "CAN":
            let newValue = value.realCAN + mo.amount
            return Money(amount: newValue, currency: mo.currency)
        default:
            print("Does Not Support This Currency")
            return self
        }
    }
}

////////////////////////////////////
// Job
//


public class Job {
    public enum JobType {
        case Hourly(Double)
        case Salary(UInt)
    }
    
    var title : String
    var type : JobType
    
    init(title tl: String, type ty: JobType) {
        title = tl
        type = ty
    }
    
    func calculateIncome(amount : Int) -> Int {
        switch type {
        case .Hourly(let x):
            let y : Int = Int(Double(x).rounded())
            return y * amount
        case .Salary(let x):
            let y : Int = Int(UInt(x))
            return y
        }
    }
    
    func raise(byPercent: Double) -> (){
        var value : Double
        switch self.type {
        case .Hourly(let x):
            value = (byPercent * 0.01 * x) + x
            self.type =  .Hourly(value)
        case .Salary(let x):
            value = Double(UInt(x))
            value = (byPercent * 0.01 * value) + value
            let y : UInt = UInt(Double(value).rounded())
            self.type =  .Salary(y)
        }
    }
    
    func raise(byAmount: Double) -> (){
        var value : Double
        switch self.type {
        case .Hourly(let x):
            value = byAmount + x
            self.type =  .Hourly(value)
        case .Salary(let x):
            value = Double(UInt(x))
            value = byAmount + value
            let y : UInt = UInt(Double(value).rounded())
            self.type =  .Salary(y)
        }
    }
    
    func raise(byAmount: Int) -> (){
        var value : Int
        switch self.type {
        case .Hourly(let x):
            value = Int(Double(x).rounded())
            value = byAmount + value
            let y : Double = Double(Int(value))
            self.type =  .Hourly(y)
        case .Salary(let x):
            value = Int(UInt(x))
            value = byAmount + value
            let y : UInt = UInt(Int(value))
            self.type =  .Salary(y)
        }
    }
}

////////////////////////////////////
// Person
//
public class Person : Hashable {
    var firstName: String
    var lastName: String
    var age: Int
    weak var job : Job? = nil
    weak var spouse : Person? = nil
    static var totalPeopleCt : Int = 0
    
    
    var fullName : String {
        get { return "\(firstName) \(lastName)" }
    }
    
    init(firstName fn: String, lastName ln: String, age a: Int) {
        firstName = fn
        lastName = ln
        age = a
        Person.totalPeopleCt += 1
    }
    
    func toString() -> String {
        var result : String
        if spouse != nil && job != nil {
            result = "[Person: firstName: \(firstName) lastName: \(lastName) age: \(age) job: \(Job.JobType.self) spouse: \(spouse!.firstName)]"
            return result
        } else if spouse != nil {
            result = "[Person: firstName: \(firstName) lastName: \(lastName) age: \(age) spouse: \(spouse!.firstName)]"
        } else if job != nil {
            result = "[Person: firstName: \(firstName) lastName: \(lastName) age: \(age) job: \(Job.JobType.self)]"
            return result
        } else {
            result = "[Person: firstName: \(firstName) lastName: \(lastName) age: \(age)]"
            return result
        }
        return result
    }
}

////////////////////////////////////
// Family
//
public class Family {
    enum marriedMoreThanOnce : Error {
        case MarriedMoreThanOnce
    }
    var members : Set<Person>
    var spouse1 : Person
    var spouse2 : Person
    
    init(spouse1 sp1: Person, spouse2 sp2: Person) throws {
        if spouse1.spouse != nil || spouse2.spouse != nil {
            throw marriedMoreThanOnce.MarriedMoreThanOnce
        }
        spouse1 = sp1
        spouse2 = sp2
        spouse1.spouse = spouse2
        spouse2.spouse = spouse1
        members.insert(spouse1)
        members.insert(spouse2)
    }
    
    func haveChild(name : Person) -> Bool {
        if spouse1.age >= 21 || spouse2 >= 21 {
            members.insert(name)
            if members.contains(name) {
                return true
            }
        }
        return false
    }
    
    func householdIncome() -> Int {
        var total : Int = 0
        for p in members{
            if p.job != nil {
                total += p.job!.calculateIncome(amount: 2000)
            }
        }
        return total
    }
}
